/**
 * This file is a part of ThetaRush.
 *
 * ThetaRush is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ThetaRush is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.
 *
 * If not, see <https://www.gnu.org/licenses/>.
 */

/* -- Attention: This file is generated by Deepseek R1 -- */

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "utils/utils.h"

#include "tr/ds/ll.h"

static trLLMemHeap_t trLLMemHeap; /**< Global memory pool instance */
static trLLInterface_t trLL;      /**< Global module interface */

/* Internal helper functions */
static int
trLLFindFreeSlot (void)
{
  for (int i = 0; i < (__TR_LL_GUARD_SIZE); i++)
    {
      if (trLLMemHeap.guard[i] != 0xFFFFFFFF)
        { // has empty bits
          for (int j = 0; j < 32; j++)
            {
              if (!(trLLMemHeap.guard[i] & (1 << j)))
                {
                  return i * 32 + j; // return index
                }
            }
        }
    }
  return -1; // Memory pool is fullfilled
}

/**
 * @brief Allocate node from memory heap
 * @return trLLNode_t* Allocated node, NULL if heap full
 */
trLLNode_t *
trLLHeapAllocNode (void)
{
  int index = trLLFindFreeSlot ();
  if (index == -1)
    return NULL;

  int guardIdx = index / 32;
  int bitPos = index % 32;
  trLLMemHeap.guard[guardIdx] |= (1 << bitPos);

  trLLNode_t *node = &trLLMemHeap.memory[index];
  node->id = 0;
  node->pd = NULL;
  node->next = node->prev = NULL;
  return node;
}

/**
 * @brief Release node back to memory heap
 * @param node Node to release
 */
void
trLLHeapFreeNode (trLLNode_t *node)
{
  if (node < trLLMemHeap.memory
      || node >= &trLLMemHeap.memory[TR_LL_HEAP_SIZE])
    return;

  int index = node - trLLMemHeap.memory;
  int guardIdx = index / 32;
  int bitPos = index % 32;
  trLLMemHeap.guard[guardIdx] &= ~(1 << bitPos);
}

/**
 * @brief Create new empty list
 * @return trLL_t* List handle, NULL if allocation fails
 */
trLL_t *
trLLCreate (void)
{
  trLLNode_t *sentinel = trLLMemHeap.new ();
  if (!sentinel)
    return NULL;

  sentinel->next = sentinel->prev = sentinel;
  sentinel->id = 0xFFFFFFFF; // Special ID for sentinel
  return sentinel;
}

/**
 * @brief Append new node to list tail
 * @param head List handle
 * @param id Node identifier
 * @param data Payload data pointer
 * @return 0 on success, -1 on failure
 */
int
trLLPushNode (trLL_t *head, uint32_t id, void *data)
{
  if (!head || head->id != 0xFFFFFFFF)
    return -1;

  trLLNode_t *newNode = trLLMemHeap.new ();
  if (!newNode)
    return -1;

  newNode->id = id;
  newNode->pd = data;
  newNode->prev = head->prev;
  newNode->next = head;

  head->prev->next = newNode;
  head->prev = newNode;
  head->len++; // Update cache
  return 0;
}

/**
 * @brief Remove node from list by ID
 * @param head List handle
 * @param id Target node ID
 * @return true if node found and removed, false otherwise
 */
bool
trLLPopNode (trLL_t *head, uint32_t id)
{
  if (!head || head->id != 0xFFFFFFFF)
    return false;

  trLLNode_t *current = head->next;
  while (current != head)
    {
      if (current->id == id)
        {
          // Bypass the node
          current->prev->next = current->next;
          current->next->prev = current->prev;

          // Return to memory pool
          trLLMemHeap.free (current);

          head->len--; // Update cache
          return true;
        }
      current = current->next;
    }
  return false;
}

/**
 * @brief Find node by ID
 * @param head List handle
 * @param id Target node ID
 * @return trLLNode_t* Found node, NULL if not found
 */
trLLNode_t *
trLLFindNode (trLL_t *head, uint32_t id)
{
  if (!head || head->id != 0xFFFFFFFF)
    return NULL;

  trLLNode_t *current = head->next;
  while (current != head)
    {
      if (current->id == id)
        {
          return current;
        }
      current = current->next;
    }
  return NULL;
}

/**
 * @brief Get the number of nodes in a linear linked list
 * @param head List handle
 * @return uint32_t Number of data nodes (0 if invalid list)
 */
uint32_t
trLLGetLength (trLL_t *head)
{
  if (!head || head->id != 0xFFFFFFFF)
    return 0;

  uint32_t count = 0;
  trLLNode_t *current = head->next;

  while (current != head)
    {
      count++;
      current = current->next;
    }
  return count;
}

/**
 * @brief Get list length with direction control
 * @param head List handle
 * @param dir Traversal direction (unused for linear list, reserved for future)
 * @return uint32_t Number of data nodes, 0 for invalid list
 */
uint32_t
trLLGetLengthEx (trLL_t *head, trLLDirection_t dir)
{
  UNUSED (dir);

  // Validate list handle and sentinel marker
  if (!head || head->id != 0xFFFFFFFF)
    {
      return 0;
    }

  // Return cached length from sentinel node
  return head->len;
}

/**
 * @brief Traverse linear list with automatic length limit
 * @param head List handle
 * @param visit Node processing callback
 * @param dir Traversal direction
 * @return Number of nodes visited
 */
uint32_t
trLLTraverse (trLL_t *head, void (*visit) (trLLNode_t *), trLLDirection_t dir)
{
  const uint32_t maxNodes = trLLGetLengthEx (head, dir);
  if (maxNodes == 0)
    return 0;

  uint32_t count = 0;
  trLLNode_t *current = (dir == TR_LL_FORWARD) ? head->next : head->prev;

  while (current != head && count < maxNodes)
    {
      visit (current);
      current = (dir == TR_LL_FORWARD) ? current->next : current->prev;
      count++;
    }
  return count;
}

/**
 * @brief Destroy entire list
 * @param head Double pointer to list handle
 */
void
trLLDestroy (trLL_t **head)
{
  if (!head || !*head)
    return;
  trLL_t *sentinel = *head;

  // Remove all data nodes
  trLLNode_t *current = sentinel->next;
  while (current != sentinel)
    {
      trLLNode_t *temp = current;
      current = current->next;
      trLLMemHeap.free (temp);
    }

  // Release sentinel node
  trLLMemHeap.free (sentinel);
  *head = NULL;
}

/**
 * @brief Create circular linked list with specified length
 * @param count Number of nodes in loop (excluding sentinel)
 * @return trLL_t* List handle, NULL if creation fails
 */
trLL_t *
trCLLCreate (uint8_t count)
{
  trLL_t *head = trLLCreate ();
  if (!head)
    return NULL;

  // Create circular references
  trLLNode_t *first = NULL;
  trLLNode_t *last = NULL;

  for (uint8_t i = 0; i < count; ++i)
    {
      trLLNode_t *node = trLLMemHeap.new ();
      if (!node)
        {
          trLLDestroy (&head);
          return NULL;
        }

      node->id = i + 1;
      if (!first)
        first = node;
      last = node;

      // Link nodes
      if (head->prev == head)
        { // First node
          head->next = node;
          node->prev = head;
        }
      else
        {
          node->prev = head->prev;
          head->prev->next = node;
        }
      head->prev = node;
      node->next = head;
    }

  // Make circular connection
  if (first && last)
    {
      first->prev = last;
      last->next = first;
    }

  return head;
}

/**
 * @brief Check if a list has circular linkage
 * @param head List handle
 * @return true if circular, false if linear or invalid
 */
bool
trCLLIf (trLL_t *head)
{
  if (!head || head->id != 0xFFFFFFFF)
    return false;

  // Floyd's cycle detection algorithm
  trLLNode_t *slow = head->next, *fast = head->next;
  while (fast && fast->next)
    {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast)
        return true;
    }
  return false;
}

/**
 * @brief Push node to circular list tail
 * @param head List handle
 * @param id Node identifier
 * @param data Payload data pointer
 * @return 0 on success, -1 on failure
 */
int
trCLLPushBack (trLL_t *head, uint32_t id, void *data)
{
  if (!head || !trCLLIf (head))
    return -1;

  trLLNode_t *newNode = trLLMemHeap.new ();
  if (!newNode)
    return -1;

  newNode->id = id;
  newNode->pd = data;

  // Insert before sentinel node
  newNode->prev = head->prev;
  newNode->next = head;
  head->prev->next = newNode;
  head->prev = newNode;

  // Maintain circular connection
  if (head->next == head)
    {
      head->next = newNode;
      newNode->prev = head->prev;
    }
  head->len++;
  return 0;
}

/**
 * @brief Remove node from circular list by ID
 * @param head List handle
 * @param id Target node ID
 * @return true if node found and removed, false otherwise
 */
bool
trCLLPopNode (trLL_t *head, uint32_t id)
{
  if (!head || !trCLLIf (head))
    return false;

  trLLNode_t *current = head->next;
  while (current != head)
    {
      if (current->id == id)
        {
          current->prev->next = current->next;
          current->next->prev = current->prev;

          // Update head connections if removing edge node
          if (head->next == current)
            head->next = current->next;
          if (head->prev == current)
            head->prev = current->prev;

          trLLMemHeap.free (current);

          head->len--;
          return true;
        }
      current = current->next;
    }
  return false;
}

/**
 * @brief Find node in circular list by ID
 * @param head List handle
 * @param id Target node ID
 * @return trLLNode_t* Found node, NULL if not found
 */
trLLNode_t *
trCLLFindNode (trLL_t *head, uint32_t id)
{
  if (!head || !trCLLIf (head))
    return NULL;

  trLLNode_t *current = head->next;
  while (current != head)
    {
      if (current->id == id)
        return current;
      current = current->next;
    }
  return NULL;
}

/**
 * @brief Get the number of nodes in a circular linked list
 * @param head List handle
 * @return uint32_t Number of data nodes (0 if invalid list)
 */
uint32_t
trCLLGetLength (trLL_t *head)
{
  if (!head || head->id != 0xFFFFFFFF || !trCLLIf (head))
    return 0;

  uint32_t count = 0;
  trLLNode_t *current = head->next;

  while (current != head)
    {
      count++;
      current = current->next;
    }
  return count;
}

/**
 * @brief Get circular list length with direction control
 * @param head List handle
 * @param dir Traversal direction (unused, consistency only)
 * @return uint32_t Number of data nodes, 0 for invalid list
 */
uint32_t
trCLLGetLengthEx (trLL_t *head, trLLDirection_t dir)
{
  UNUSED (dir);
  // Use cached length if valid circular list
  if (head && head->id == 0xFFFFFFFF && trCLLIf (head))
    return head->len;
  return 0;
}

/**
 * @brief Traverse circular list with automatic length limit
 * @param head List handle
 * @param visit Node processing callback
 * @param dir Traversal direction
 * @return Number of nodes visited
 */
uint32_t
trCLLTraverse (trLL_t *head, void (*visit) (trLLNode_t *), trLLDirection_t dir)
{
  const uint32_t maxNodes = trCLLGetLengthEx (head, dir);
  if (maxNodes == 0)
    return 0;

  uint32_t count = 0;
  trLLNode_t *current = (dir == TR_LL_FORWARD) ? head->next : head->prev;
  trLLNode_t *start = current;

  do
    {
      visit (current);
      current = (dir == TR_LL_FORWARD) ? current->next : current->prev;
      count++;
    }
  while (current != start && count < maxNodes);

  return count;
}

/**
 * @brief Break circular linkage to linear list
 * @param head List handle
 * @return true if successfully broken, false otherwise
 */
bool
trLCLLBreak (trLL_t *head)
{
  if (!head || head->id != 0xFFFFFFFF || !trCLLIf (head))
    return false;

  trLLNode_t *first = head->next;
  trLLNode_t *last = head->prev;

  // Restore normal linkage
  first->prev = head;
  last->next = head;
  return true;
}

/**
 * @brief Rotate circular list by N positions
 * @param head List handle
 * @param steps Number of positions to cllRotate (positive: forward)
 */
void
trLCLLRotate (trLL_t *head, int32_t steps)
{
  if (!head || head->id != 0xFFFFFFFF || !trCLLIf (head))
    return;

  trLLNode_t *newHead = head->next;
  int absSteps = steps < 0 ? -steps : steps;

  // Find new head position
  for (int i = 0; i < absSteps; ++i)
    {
      if (steps > 0)
        {
          newHead = newHead->next;
        }
      else
        {
          newHead = newHead->prev;
        }
    }

  // Adjust sentinel node links
  head->next = newHead;
  head->prev = newHead->prev;
  newHead->prev->next = head;
  newHead->prev = head;
}

/**
 * @brief Destroy a circular linked list and release all resources
 * @param head Double pointer to the list handle
 */
void
trCLLDestroy (trLL_t **head)
{
  /* Parameter validation */
  if (!head || !*head)
    return;

  trLL_t *sentinel = *head;

  /* Verify sentinel node */
  if (sentinel->id != 0xFFFFFFFF)
    {
      *head = NULL;
      return;
    }

  /* Break circular linkage if necessary */
  if (trCLLIf (sentinel))
    {
      /* Restore linear connection */
      trLLNode_t *first = sentinel->next;
      trLLNode_t *last = sentinel->prev;

      first->prev = sentinel;
      last->next = sentinel;
    }

  /* Release all data nodes */
  trLLNode_t *current = sentinel->next;
  while (current != sentinel)
    {
      trLLNode_t *temp = current;
      current = current->next;

      /* Clear node references */
      temp->prev = NULL;
      temp->next = NULL;

      /* Return to memory pool */
      trLLMemHeap.free (temp);
    }

  /* Clear sentinel references */
  sentinel->next = sentinel;
  sentinel->prev = sentinel;

  /* Release sentinel node */
  trLLMemHeap.free (sentinel);

  /* Nullify handle */
  *head = NULL;
}

/**
 * @brief Initialize module interface
 */
void
trLLInitModule (void)
{
  // Memory heap initialization
  for (int i = 0; i < __TR_LL_GUARD_SIZE; ++i)
    {
      trLLMemHeap.guard[i] = 0;
    }
  trLLMemHeap.new = trLLHeapAllocNode;
  trLLMemHeap.free = trLLHeapFreeNode;

  trLL.heap = &trLLMemHeap;

  /* Bind linear list functions */
  trLL.create = trLLCreate;
  trLL.pushBack = trLLPushNode;
  trLL.popNode = trLLPopNode;
  trLL.find = trLLFindNode;
  trLL.getLength = trLLGetLength;
  trLL.getLengthEx = trLLGetLengthEx;
  trLL.traverse = trLLTraverse;
  trLL.destroy = trLLDestroy;

  /* Bind circular list functions */
  trLL.cllCreate = trCLLCreate;
  trLL.cllIf = trCLLIf;
  trLL.cllPushBack = trCLLPushBack;
  trLL.cllPopNode = trCLLPopNode;
  trLL.cllFindNode = trCLLFindNode;
  trLL.cllGetLength = trCLLGetLength;
  trLL.cllGetLengthEx = trCLLGetLengthEx;
  trLL.cllTraverse = trCLLTraverse;
  trLL.cllBreak = trLCLLBreak;
  trLL.cllRotate = trLCLLRotate;
  trLL.cllDestroy = trCLLDestroy;
}

trLLInterface_t* trLLInterfaceHandle(void)
{
    return &trLL;
}
